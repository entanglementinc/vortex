/************************************************************
 * @(#)ToyCryptoModule.java
 * 
 * Generated by KeyGeneratorCS V 1.0alpha Sun Jul 14 23:45:35 2002
 * Created : Feb 6, 2003 9:41:06 PM
 *
 * Requires: java 1.1.5 (or higher)
 * 
 * 
 *           [as e.g. provided in Netscape 4.06]
 *
 * References:
 * 
 * [CS98] Ronald Cramer and Victor Shoup: A practical public key crypto
 *        system provably secure against adaptive chosen  ciphertext attack
 *        in proceedings of Crypto 1998, LNCS 1462, p.13ff  
 * 
 * No Copyright (!c)
 */


import java.math.BigInteger;
import java.util.Random;

  /**
   * DummyCryptoModule implements the Cramer-Shoup 
   * public key Crypto Algorithm
   *
   * If you want to use it, you can find more information on:
   * <PRE>
   * see: http://www.verify-it.de/sub/cramer_shoup.html
   *      http://www.verify-it.de/sub/crypter.html
   *      http://www.verify-it.de/applet/KeyGeneratorCS.java
   * </PRE>
   * 
   */
public class DummyCryptoModule {

    /************************************************************
     * Public and secret keys
     ************************************************************/
    

  public String keyNameString = "Method:   Cramer-Shoup98\nKey-Name: dummy\nOwner:    Nobody <should@use.this.com>\n";
  
  private SecretKey sk;
  private PublicKey pk;
  
  private Random rnd;
  
  public DummyCryptoModule(){
    
    /****************************************
     * Initialize:
     * Set the keys to personal adjustings
     ****************************************/
    
    /*
     * Method:   Cramer-Shoup98
     * Key-Name: dummy
     * Owner:    Nobody <should@use.this.com>


     (12 
      "111100000001" // P: 0x80F
      "00111101"     // g1: 0xBC
      "011111101"    // g2: 0x17E
      "01100101011"  // c : 0x6A6
      "10110010111"  // d : 0x74D
      "1100001111"   // h : 0x3C3
      ("0001001001"  "0000100011"))) // h1,h2: 0x248, 0x310
   

SECRET:
    '(12 
      "111100000001" // p : 0x80F
      "100000011"    // x1: 0x181
      "00010000101"  // x2: 0x508
      "100001001"    // y1: 0x121
      "10001111101"  // y2: 0x5F1
      "10011001101"  // z : 0x599
      ("0001001001" 
       "0000100011"))) // h1,h2: 0x248, 0x310

     */
    
    byte[] p =   { 0x08, 0x0f };
    byte[] hg1 = { 0x02, 0x48 };
    byte[] hg2 = { 0x03, 0x10 };
    
    byte[] g1 = { 0x00, -(0x100-0xBC) };
    byte[] g2 = { 0x01, 0x7E };
    
    
    byte[] c = {  0x06, -(0x100-0xA6) };
    byte[] d = {  0x07, 0x4D };
    byte[] h = { 0x03, -(0x100-0xC3) };
    
    /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     * SECRET KEY components start here [replace via { 0 }] 
     * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     */
    byte[] x1 = { 0x01, -(0x100-0x81) };
    byte[] x2 = { 0x05, 0x08 };
    byte[] y1 = { 0x01, 0x21 };
    byte[] y2 = { 0x05, -(0x100-0xf1) };
    byte[] z =  { 0x05, -(0x100-0x99) };
    //****************************************
    
    pk = new PublicKey(12,p,g1,g2,c,d,h,hg1,hg2);
    sk = new SecretKey(12,p,x1,x2,y1,y2,z,hg1,hg2);
    
    
    
    /****************************************
     * Initiatize random generator
     ****************************************/
    
    rnd = new Random();
  }
  
  
  /************************************************************
   * Converter Methods
   ************************************************************/
  
  private BigInteger bits2BigInteger(boolean[] bits){
    int len = bits.length;
    byte[] bytes = new byte[2 + (len/8)];
    int b;
    int index = 1+ len/8;
    int bitIndex = 0;
    
    // in bits:  least significant bit comes first
    // in bytes: most significant bit is first!
    
    bytes[0] = 0;  // play safe - we do not want a negative number...
    bytes[1] = 0;
    
    while(bitIndex<len){
      b = 0;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|1;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|2;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|4;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|8;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|16;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|32;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|64;
      if((bitIndex<len)&&(bits[bitIndex++]))b = b|128;
      bytes[index--] = (byte)b;
    }
    return new BigInteger(bytes);
  }
  
  private boolean[] bigInteger2bits(int k, BigInteger b){
    boolean[] bits = new boolean[k];
    int i;
    
    for(i = 0; i< k; i++)
      bits[i] = b.testBit(i);
    return bits;
  }
  
  
  /************************************************************
   * Hashing
   ************************************************************/
  
  private BigInteger hashOnOneNumber(BigInteger p,
				     BigInteger hg1,
				     BigInteger hg2,
				     BigInteger nn){
    BigInteger q = p.shiftRight(1); // -1 div 2
    return hashOnTwoNumbers(p,hg1,hg2,nn.divide(q),nn.mod(q));
  }
  private BigInteger hashOnTwoNumbers(BigInteger p,
				      BigInteger hg1,
				      BigInteger hg2,
				      BigInteger a1,
				      BigInteger a2){
    return ((hg1.modPow(a1,p)).multiply(hg2.modPow(a2,p))).mod(p);
  }
  
  private BigInteger hashBitList(int k,
				 BigInteger p,
				 HashFunction hash,
				 boolean[] bits){
    BigInteger hg1 = hash.hash_g1;
    BigInteger hg2 = hash.hash_g2;
    
    int m   = k+k-2;
    int len = m - k - 1; // the length of ONE hash component
    int lengthDeficit = len - (bits.length % len);
    int index = - lengthDeficit; 
    int i;
    BigInteger arg;
    byte[] zero = {0};
    BigInteger res = new BigInteger(zero);
    BigInteger e;
    boolean[] transferList = new boolean[len];
    
    while(index < bits.length){
      // copy bits
      for(i = 0; i < len; i++){
	if(index < 0)
	  transferList[i] = false;
	else
	  transferList[i] = bits[index];
	index++;}
      
      arg = bits2BigInteger(transferList).add((res.shiftLeft(1)).setBit(0).shiftLeft(len));
      res = hashOnOneNumber(p, hg1, hg2, arg);
    }
    return res;
  }
  
  /************************************************************
   * Auxillary
   ************************************************************/
  
  private BigInteger bigRandom(int bits){
    // there should be a constructor with signature
    // BigInteger(int bits, Random rnd) that does that job....
    // only my compiler cannot find it for some reason.
    int nbytes = 2+bits/8;
    int i;
    int b;
    byte[] bytes = new byte[nbytes];
    
    for(i=1; i< nbytes; i++){
      b = (rnd.nextInt()) % 256;
      if(b>127)b = b - 256;
      bytes[i] = (byte)b;}
    bytes[0] = 1;
    
    return new BigInteger(bytes);
  };
  
  private boolean[] bitListOne(int k,
			       BigInteger b1){
    // LEAST significant bits first...
    boolean[] res = new boolean[k];
    int i;
    int index = 0;
    
    for(i = 0; i <k ; i++)
      res[index++] = b1.testBit(i);
    return res;
  }
  
  private boolean[] bitListThree(int k,
				 BigInteger b1,
				 BigInteger b2,
				 BigInteger b3){
    // LEAST significant bits first...
    boolean[] res = new boolean[3*k];
    int i;
    int index = 0;
    
    for(i = 0 ; i < k; i++)
      res[index++] = b1.testBit(i);
    for(i = 0 ; i < k; i++)
      res[index++] = b2.testBit(i);
    for(i = 0 ; i < k; i++)
      res[index++] = b3.testBit(i);
    
    return res;
  }
  private boolean[] bitListFour(int k,
				  BigInteger b1,
				  BigInteger b2,
				  BigInteger b3,
				  BigInteger b4){
	// least significant bits first...
	boolean[] res = new boolean[4*k];
	int i;
	int index = 0;

	for(i = 0 ; i < k; i++)
	    res[index++] = b1.testBit(i);
	for(i = 0 ; i < k; i++)
	    res[index++] = b2.testBit(i);
	for(i = 0 ; i < k; i++)
	    res[index++] = b3.testBit(i);
	for(i = 0 ; i < k; i++)
	    res[index++] = b4.testBit(i);

	return res;
    }

    /************************************************************
     * --  Encrypting  --
     ************************************************************/
    
	public boolean[] encrypt(boolean[] message){
	/***
	 * Returns a (big) array representing the
	 * concatenation of encryption blocks
	 *        [u1 u2 e v]
	 * Since the (bit-)length of each component of the block is given
	 * with k, it is not neccessary to encapsulate those additionally.
	 **************************************************/
	    
	    int messageLength = message.length;
	    int el            = pk.k - 1; // one 'bit' is not complete 
	    int i;
	    int toEncrypt     = (1+ (message.length / el))*pk.k*4;
	    boolean[] mChunk  = new boolean[pk.k];
	    mChunk[el] = false; // force positive number
	    boolean[] cChunk  = new boolean[pk.k*4];
	    boolean[] res     = new boolean[toEncrypt];
	    int resIndex      = 0;
	    
	    BigInteger r,u1,u2,e,m,alpha,v;

	    int pointer = 0;
	    int index = 0;


	    while(pointer < messageLength){
		index = 0;
		while((index < el)&&(pointer < messageLength))
		    mChunk[index++] = message[pointer++];
		while(index + 1 < el){ // fill with random 01/10 bits
		    mChunk[index] = ( (rnd.nextInt() & 1) == 1);
		    mChunk[index+1] = !mChunk[index];
		    index = index + 2;
		}
		if(index < el)
		    mChunk[index] = true;
		
		m  = bits2BigInteger(mChunk);
		if(m.equals(BigInteger.ZERO)){ // avoid to encrypt a '0'.
		    mChunk[el] = true; 	       // instead fill throwaway-bit
		    m = bits2BigInteger(mChunk);
		}

		r = bigRandom(pk.k+1).mod(pk.p);
		u1 = pk.g1.modPow(r,pk.p);
		u2 = pk.g2.modPow(r,pk.p);
		e  = ((pk.h.modPow(r,pk.p)).multiply(m)).mod(pk.p);
		alpha = hashBitList(pk.k,pk.p,pk.hash,bitListThree(pk.k,u1,u2,e));
		v = ((pk.c.modPow(r,pk.p)).multiply(pk.d.modPow(r.multiply(alpha),pk.p))).mod(pk.p);
		cChunk = bitListFour(pk.k,u1,u2,e,v);
		
		for(i=0; i < 4*pk.k; i++)
		    res[resIndex++] = cChunk[i];
	    }
	    return res;

	}
    
    /************************************************************
     * --  Decrypting  --
     ************************************************************/

    public boolean[] decrypt(boolean[] cryptoText){
	boolean[] res = new boolean[((cryptoText.length / (4 * sk.k))+1)*(sk.k-1)];
	// one bit (the most significant one ) is always lost, since it is 0.
	
	boolean[] cChunk = new boolean[sk.k];
	boolean[] mChunk = new boolean[sk.k];
	BigInteger c;
	int index = 0;
	int resIndex = 0;
	int len   = cryptoText.length;
	int i;

	byte[] zero = {0};
	BigInteger zeroBig = new BigInteger(zero); // will be returned, if key is faulty
	BigInteger u1,u2,e,v,alpha,m;

	while(index+(4*sk.k) <= len){ // only decrypt complete blocks
	    // Copy --- with all bits.
	    for(i = 0; i< sk.k; i++)
		cChunk[i] = cryptoText[index++];
	    u1 = bits2BigInteger(cChunk);
	    for(i = 0; i< sk.k; i++)
		cChunk[i] = cryptoText[index++];
	    u2 = bits2BigInteger(cChunk);
	    for(i = 0; i< sk.k; i++)
		cChunk[i] = cryptoText[index++];
	    e  = bits2BigInteger(cChunk);
	    for(i = 0; i< sk.k; i++)
		cChunk[i] = cryptoText[index++];
	    v = bits2BigInteger(cChunk);
	    
	    alpha = hashBitList(sk.k,sk.p,sk.hash,bitListThree(sk.k,u1,u2,e));
	    
	    if((v.equals(((u1.modPow(sk.x1.add(alpha.multiply(sk.y1)),sk.p)                    ).multiply(u2.modPow(sk.x2.add(alpha.multiply(sk.y2)),sk.p))).mod(sk.p))))
		{
		    if(u1.equals(BigInteger.ZERO))
			m = BigInteger.ZERO;
		    else
		        m = (e.multiply((u1.modPow(sk.z,sk.p)).modInverse(sk.p))).mod(sk.p);
		    cChunk = bigInteger2bits(sk.k, m);
		    for(i = 0; i < sk.k - 1; i++) // ignore most significant bit
			res[resIndex++] = cChunk[i];
		}
	    else
		for(i = 0; i < sk.k-1;  i++)
		    res[resIndex++] = true; // fill with ones
	}
		
	return res;
    }
}


/**
 * Auxillary data structure for hash function
 * 
 * @version $Revision: 1.1 $	$Date: 2006/10/21 12:30:48 $
 */
class HashFunction {
    BigInteger hash_g1;
    BigInteger hash_g2;

    HashFunction(byte[] hash_g1_rep,
		byte[] hash_g2_rep){
	hash_g1 = new BigInteger(hash_g1_rep);
	hash_g2 = new BigInteger(hash_g2_rep);
    }
}

/**
 * Definition of the records structure of the keys<BR>
 *
 * The variable names used correspond to the ones in [CS98]
 *
 * @version $Revision: 1.1 $      $Date: 2006/10/21 12:30:48 $
 */


class SecretKey {
    int          k;        // number of bits
    BigInteger   p;        // prime modulus
    BigInteger   x1;          
    BigInteger   x2;
    BigInteger   y1;
    BigInteger   y2;
    BigInteger   z;
    HashFunction hash;
    
    SecretKey(int k_id,
	      byte[] p_rep,
	      byte[] x1_rep,
	      byte[] x2_rep,
	      byte[] y1_rep,
	      byte[] y2_rep,
	      byte[] z_rep,
	      byte[] hash_g1_rep,
	      byte[] hash_g2_rep){
	k = k_id;
	p  = new BigInteger(p_rep);
	x1 = new BigInteger(x1_rep);
	x2 = new BigInteger(x2_rep);
	y1 = new BigInteger(y1_rep);
	y2 = new BigInteger(y2_rep);
	z  = new BigInteger(z_rep);
	hash = new HashFunction(hash_g1_rep,hash_g2_rep);
    }
}

class PublicKey {
    int          k;
    BigInteger   p;
    BigInteger   g1;
    BigInteger   g2;
    BigInteger   c;
    BigInteger   d;
    BigInteger   h;
    HashFunction hash;

    PublicKey(int k_id,
	      byte[] p_rep,
	      byte[] g1_rep,
	      byte[] g2_rep,
	      byte[] c_rep,
	      byte[] d_rep,
	      byte[] h_rep,
	      byte[] hash_g1_rep,
	      byte[] hash_g2_rep){
	k  = k_id;
	p  = new BigInteger(p_rep);
	g1 = new BigInteger(g1_rep);
	g2 = new BigInteger(g2_rep);
	c  = new BigInteger(c_rep);
	d  = new BigInteger(d_rep);
	h  = new BigInteger(h_rep);


	System.out.println(p);
	hash = new HashFunction(hash_g1_rep,hash_g2_rep);
    }

}






